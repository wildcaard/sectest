"""Markdown report generator."""

from datetime import datetime
from pathlib import Path
from typing import Any

from security_agent.models.report import Report


class MarkdownReportGenerator:
    """Generates a Markdown-formatted security report."""

    SEVERITY_ORDER = ["critical", "high", "medium", "low", "info"]

    def generate(self, report: Report, output_path: str) -> str:
        """Render the report as a Markdown document.

        Args:
            report: The Report object.
            output_path: Destination file path.

        Returns:
            The absolute path of the written file.
        """
        lines: list[str] = []
        sr = report.scan_result
        meta = report.metadata

        # ----------------------------------------------------------
        # Title & Metadata
        # ----------------------------------------------------------
        lines.append(f"# Security Assessment Report")
        lines.append("")
        lines.append(f"**Target:** {sr.target_url}  ")
        lines.append(f"**Scan ID:** {sr.scan_id}  ")
        lines.append(f"**Date:** {self._format_datetime(sr.start_time)}  ")
        lines.append(f"**Duration:** {sr.duration}  ")
        lines.append(f"**Profile:** {sr.profile}  ")
        if meta:
            lines.append(f"**Generated by:** {meta.generated_by if hasattr(meta, 'generated_by') else 'SecTest Agent'}  ")
        lines.append("")

        # ----------------------------------------------------------
        # Disclaimer
        # ----------------------------------------------------------
        lines.append("---")
        lines.append("")
        lines.append("> **Disclaimer:** This report is generated by an automated security scanning tool ")
        lines.append("> and is intended for authorized security assessments only. Findings should be ")
        lines.append("> validated by a qualified security professional before taking action. False ")
        lines.append("> positives may exist. The authors assume no liability for actions taken based ")
        lines.append("> on this report.")
        lines.append("")
        lines.append("---")
        lines.append("")

        # ----------------------------------------------------------
        # Table of Contents
        # ----------------------------------------------------------
        lines.append("## Table of Contents")
        lines.append("")
        lines.append("1. [Executive Summary](#executive-summary)")
        lines.append("2. [Scope & Methodology](#scope--methodology)")
        lines.append("3. [Technology Stack](#technology-stack)")
        lines.append("4. [Vulnerability Details](#vulnerability-details)")
        lines.append("5. [Remediation Roadmap](#remediation-roadmap)")
        lines.append("")

        # ----------------------------------------------------------
        # Executive Summary
        # ----------------------------------------------------------
        lines.append("## Executive Summary")
        lines.append("")
        lines.append(f"| Metric | Value |")
        lines.append(f"|--------|-------|")
        lines.append(f"| Security Score | **{sr.security_score}/100** |")
        lines.append(f"| Grade | **{sr.grade}** |")
        lines.append(f"| Total Vulnerabilities | {len(sr.vulnerabilities)} |")

        severity_counts = sr.severity_counts
        for sev in self.SEVERITY_ORDER:
            count = severity_counts.get(sev, 0)
            if count > 0:
                badge = self._severity_badge(sev)
                lines.append(f"| {badge} | {count} |")

        lines.append(f"| Human Reviewed | {'Yes' if sr.human_reviewed else 'No'} |")
        lines.append("")

        if report.executive_summary:
            lines.append(report.executive_summary)
            lines.append("")

        if report.ai_risk_assessment:
            lines.append("### AI Risk Assessment")
            lines.append("")
            lines.append(report.ai_risk_assessment)
            lines.append("")

        # ----------------------------------------------------------
        # Scope & Methodology
        # ----------------------------------------------------------
        lines.append("## Scope & Methodology")
        lines.append("")
        lines.append(f"- **Target URL:** {sr.target_url}")
        lines.append(f"- **Scan Profile:** {sr.profile}")
        lines.append(f"- **Total Requests Made:** {sr.total_requests}")
        lines.append(f"- **Scanners Used:**")
        for scanner in sr.scanners_run:
            lines.append(f"  - {scanner}")
        lines.append("")

        if sr.errors:
            lines.append("### Errors Encountered")
            lines.append("")
            for error in sr.errors:
                lines.append(f"- {error}")
            lines.append("")

        # ----------------------------------------------------------
        # Technology Stack
        # ----------------------------------------------------------
        lines.append("## Technology Stack")
        lines.append("")

        if sr.technologies_detected:
            lines.append("| Category | Technology |")
            lines.append("|----------|-----------|")
            for category, tech in sr.technologies_detected.items():
                value = tech if isinstance(tech, str) else ", ".join(tech) if isinstance(tech, list) else str(tech)
                lines.append(f"| {category} | {value} |")
            lines.append("")
        else:
            lines.append("_No technologies were detected._")
            lines.append("")

        # ----------------------------------------------------------
        # Vulnerability Details
        # ----------------------------------------------------------
        lines.append("## Vulnerability Details")
        lines.append("")

        sorted_vulns = self._sort_by_severity(sr.vulnerabilities)

        if not sorted_vulns:
            lines.append("_No vulnerabilities were discovered during this scan._")
            lines.append("")
        else:
            lines.append(f"A total of **{len(sorted_vulns)}** vulnerabilities were identified.")
            lines.append("")

            for idx, vuln in enumerate(sorted_vulns, 1):
                sev_badge = self._severity_badge(vuln.severity.value if hasattr(vuln.severity, 'value') else str(vuln.severity))
                lines.append(f"### {idx}. {vuln.title}")
                lines.append("")
                lines.append(f"| Property | Value |")
                lines.append(f"|----------|-------|")
                lines.append(f"| Severity | {sev_badge} |")
                lines.append(f"| CVSS Score | {vuln.cvss_score if vuln.cvss_score is not None else 'N/A'} |")
                lines.append(f"| CWE | {vuln.cwe_id or 'N/A'} |")
                lines.append(f"| Category | {vuln.category.value if hasattr(vuln.category, 'value') else vuln.category} |")
                lines.append(f"| URL | `{vuln.url or 'N/A'}` |")
                lines.append(f"| Scanner | {vuln.scanner_name or 'N/A'} |")
                if vuln.owasp_category:
                    lines.append(f"| OWASP | {vuln.owasp_category} |")
                if vuln.human_verified:
                    lines.append(f"| Human Verified | Yes |")
                lines.append("")

                lines.append("**Description:**")
                lines.append("")
                lines.append(vuln.description or "_No description provided._")
                lines.append("")

                if vuln.evidence:
                    lines.append("**Evidence:**")
                    lines.append("")
                    lines.append("```")
                    lines.append(str(vuln.evidence))
                    lines.append("```")
                    lines.append("")

                if vuln.remediation:
                    lines.append("**Remediation:**")
                    lines.append("")
                    lines.append(vuln.remediation)
                    lines.append("")

                if vuln.ai_analysis:
                    lines.append("**AI Analysis:**")
                    lines.append("")
                    lines.append(vuln.ai_analysis)
                    lines.append("")

                if vuln.ai_fix_suggestion:
                    lines.append("**Suggested Fix:**")
                    lines.append("")
                    lines.append("```")
                    lines.append(vuln.ai_fix_suggestion)
                    lines.append("```")
                    lines.append("")

                if vuln.references:
                    lines.append("**References:**")
                    lines.append("")
                    for ref in vuln.references:
                        lines.append(f"- {ref}")
                    lines.append("")

                if vuln.human_notes:
                    lines.append(f"> **Reviewer Notes:** {vuln.human_notes}")
                    lines.append("")

                lines.append("---")
                lines.append("")

        # ----------------------------------------------------------
        # Remediation Roadmap
        # ----------------------------------------------------------
        lines.append("## Remediation Roadmap")
        lines.append("")

        if report.remediation_roadmap:
            roadmap = report.remediation_roadmap
            if isinstance(roadmap, dict):
                for phase, items in roadmap.items():
                    lines.append(f"### {phase}")
                    lines.append("")
                    if isinstance(items, list):
                        for item in items:
                            lines.append(f"- {item}")
                    else:
                        lines.append(str(items))
                    lines.append("")
            elif isinstance(roadmap, str):
                lines.append(roadmap)
                lines.append("")
        else:
            # Auto-generate from vulnerabilities
            quick_wins, short_term, long_term = self._categorise_remediation(sorted_vulns)

            lines.append("### Quick Wins (0-1 week)")
            lines.append("")
            if quick_wins:
                for item in quick_wins:
                    lines.append(f"- {item}")
            else:
                lines.append("_None identified._")
            lines.append("")

            lines.append("### Short-Term (1-4 weeks)")
            lines.append("")
            if short_term:
                for item in short_term:
                    lines.append(f"- {item}")
            else:
                lines.append("_None identified._")
            lines.append("")

            lines.append("### Long-Term (1-3 months)")
            lines.append("")
            if long_term:
                for item in long_term:
                    lines.append(f"- {item}")
            else:
                lines.append("_None identified._")
            lines.append("")

        # ----------------------------------------------------------
        # Write to file
        # ----------------------------------------------------------
        content = "\n".join(lines)

        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w", encoding="utf-8") as fh:
            fh.write(content)

        return str(Path(output_path).resolve())

    # ------------------------------------------------------------------
    # Helper methods
    # ------------------------------------------------------------------

    def _sort_by_severity(self, vulnerabilities) -> list:
        """Return vulnerabilities sorted by severity (critical first)."""
        def _key(v):
            sev = v.severity.value if hasattr(v.severity, "value") else str(v.severity)
            try:
                return self.SEVERITY_ORDER.index(sev.lower())
            except ValueError:
                return 999
        return sorted(vulnerabilities, key=_key)

    @staticmethod
    def _severity_badge(severity: str) -> str:
        icons = {
            "critical": "\u26d4 Critical",
            "high": "\U0001f534 High",
            "medium": "\U0001f7e1 Medium",
            "low": "\U0001f535 Low",
            "info": "\u2139\ufe0f Info",
        }
        return icons.get(severity.lower(), severity)

    def _categorise_remediation(self, vulns) -> tuple[list[str], list[str], list[str]]:
        """Split vulnerabilities into remediation time-frames."""
        quick: list[str] = []
        short: list[str] = []
        long: list[str] = []

        for v in vulns:
            sev = v.severity.value if hasattr(v.severity, "value") else str(v.severity)
            label = f"[{sev.upper()}] {v.title}"
            sev_lower = sev.lower()

            if sev_lower == "info":
                quick.append(label)
            elif sev_lower == "low":
                quick.append(label)
            elif sev_lower == "medium":
                short.append(label)
            elif sev_lower == "high":
                short.append(label)
            elif sev_lower == "critical":
                long.append(label)
                # Critical also gets a short-term workaround entry
                short.append(f"Apply workaround / WAF rule for: {v.title}")

        return quick, short, long

    @staticmethod
    def _format_datetime(datetime_str: str, format_str: str = '%Y-%m-%d %H:%M:%S') -> str:
        """Format an ISO datetime string using strftime format."""
        if not datetime_str:
            return 'N/A'
        try:
            # Parse ISO format datetime string
            dt = datetime.fromisoformat(datetime_str)
            return dt.strftime(format_str)
        except (ValueError, TypeError):
            # If parsing fails, return the original string
            return str(datetime_str)
